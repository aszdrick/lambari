
#include "evaluator/evaluator.hpp"
#include "evaluator/expr.hpp"

// falk::ev::evaluator::program falk::ev::evaluator::append(program, command) {
// 	return program{};
// }

// falk::ev::evaluator::array_index falk::ev::evaluator::make_array_index(value) {
// 	return array_index{};
// }

// falk::ev::evaluator::assignment falk::ev::evaluator::assign(identifier id, value val) {
// 	mapper.assign(id, val);
// 	return val; // é ou não - GRAF, Merlseson. 2016.
// }

// falk::ev::evaluator::assignment falk::ev::evaluator::assign(identifier id, value val, op::Arithmetical op) {
// 	auto curr_value = mapper.get(id);
// 	// TODO: apply op(curr_value, val)
// 	// mapper.assign(id, ??);
// 	return assignment{};
// }

// falk::ev::evaluator::program falk::ev::evaluator::create_program() {
// 	return program{};
// }
// falk::ev::evaluator::command falk::ev::evaluator::empty_command() {
// 	return command{};
// }

// falk::ev::evaluator::declaration falk::ev::evaluator::declare_array(const std::string&) {
// 	return declaration{};
// }
// falk::ev::evaluator::declaration falk::ev::evaluator::declare_array(const std::string&, array_index) {
// 	return declaration{};
// }
// falk::ev::evaluator::declaration falk::ev::evaluator::declare_array(const std::string&, init_list) {
// 	return declaration{};
// }

// falk::ev::evaluator::declaration falk::ev::evaluator::declare_variable(const std::string&) {
// 	return declaration{};
// }
// falk::ev::evaluator::declaration falk::ev::evaluator::declare_variable(const std::string&, Type) {
// 	return declaration{};
// }
// falk::ev::evaluator::declaration falk::ev::evaluator::declare_variable(const std::string&, value) {
// 	return declaration{};
// }

// falk::ev::evaluator::declaration falk::ev::evaluator::declare_matrix(const std::string&) {
// 	return declaration{};
// }
// falk::ev::evaluator::declaration falk::ev::evaluator::declare_matrix(const std::string&, matrix_index) {
// 	return declaration{};
// }
// falk::ev::evaluator::declaration falk::ev::evaluator::declare_matrix(const std::string&, init_list) {
// 	return declaration{};
// }

// value falk::ev::evaluator::make_real(const std::string& text) {
// 	return value{};
// }

// value falk::ev::evaluator::make_complex(const std::string& text) {
// 	return value{};
// }

// value falk::ev::evaluator::make_boolean(const std::string& yytext) {
// 	return value{};
// }

// falk::ev::evaluator::matrix_index falk::ev::evaluator::make_matrix_index(value) {
// 	return matrix_index{};
// }

// falk::ev::evaluator::matrix_index falk::ev::evaluator::make_matrix_index(value, value) {
// 	return matrix_index{};
// }

// control new_line() {
// 	return control{};
// }

// falk::ev::evaluator::control falk::ev::evaluator::semicolon() {
// 	return control{};
// }

// falk::ev::evaluator::identifier falk::ev::evaluator::retrieve_identifier(const std::string&) {
// 	return identifier{};
// }
// falk::ev::evaluator::identifier falk::ev::evaluator::retrieve_identifier(const std::string&, array_index) {
// 	return identifier{};
// }
// falk::ev::evaluator::identifier falk::ev::evaluator::retrieve_identifier(const std::string&, matrix_index) {
// 	return identifier{};
// }

// falk::ev::evaluator::value falk::ev::evaluator::pow(const value& lhs,
//                                                     const value& rhs) {
//     auto type = falk::resolve_types(lhs.type, rhs.type);
//     if (type == Type::REAL) {
//         // TODO
//     } else {
//         // TODO
//     }
//     return value{};
// }

