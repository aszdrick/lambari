%{
#include <string>
#include "parser.h" /* Generated by Bison */

extern int yylineno;
void yyerror(const char* s, ...);
%}

%option noyywrap nodefault yylineno

var_decl var
arr_decl array
mat_decl matrix

real_type real
complex_type complex 
bool_type bool 

real [0-9]+|[0-9]*\.[0-9]+
complex {real}i
bool_literal true|false
name [a-zA-Z][a-zA-Z0-9_]*

if_literal if
else_literal else
for_literal for
while_literal while

end_of_command ;|\n

%%

[ \t]				;

{real_type}         { Type type(PrimitiveType::REAL); yylval.type = type; return T_TYPE; }
{complex_type}      { Type type(PrimitiveType::COMPLEX); yylval.type = type; return T_TYPE; }
{bool_type}         { Type type(PrimitiveType::BOOL); yylval.type = type; return T_TYPE; }

{var_decl}			{ return T_VAR; }
{arr_decl}			{ return T_ARRAY; }
{mat_decl}			{ return T_MATRIX; }

{real}       		{ Type type(PrimitiveType::REAL); yylval.value = {strdup(yytext), type}; return T_REAL; }
{complex}     		{ Type type(PrimitiveType::COMPLEX); yylval.value = {strdup(yytext), type}; return T_COMPLEX; }
{bool_literal}      { Type type(PrimitiveType::BOOL); yylval.value = {strdup(yytext), type}; return T_BOOL; }

{if_literal}        { return T_IF; }
{else_literal}	 	{ return T_ELSE; }

{for_literal}       { return T_FOR; }
{while_literal}     { return T_WHILE; }
in 					{ return T_IN; }
return              { return T_RET; }
function            { return T_FUN; }

{name}              { yylval.var = strdup(yytext); return T_ID; }

typeof				{ return T_TYPEOF; }

"+"                 { yylval.arithmetical = falk::op::Arithmetical::ADD; return T_PLUS; }
"-"                 { yylval.arithmetical = falk::op::Arithmetical::SUB; return T_MINUS; }
"*"                 { yylval.arithmetical = falk::op::Arithmetical::MULT; return T_TIMES; }
"/"                 { yylval.arithmetical = falk::op::Arithmetical::DIV; return T_DIVIDE; }
"**"                { yylval.arithmetical = falk::op::Arithmetical::POW; return T_POWER; }
"%"                 { yylval.arithmetical = falk::op::Arithmetical::MOD; return T_MOD; }
"=="                { yylval.comparison = falk::op::Comparison::EQ; return T_COMPARISON; }
"!="                { yylval.comparison = falk::op::Comparison::NE; return T_COMPARISON; }
">"                 { yylval.comparison = falk::op::Comparison::GT; return T_COMPARISON; }
"<"                 { yylval.comparison = falk::op::Comparison::LT; return T_COMPARISON; }
">="                { yylval.comparison = falk::op::Comparison::GE; return T_COMPARISON; }
"<="                { yylval.comparison = falk::op::Comparison::LE; return T_COMPARISON; }
"&"                 { yylval.logical = falk::op::Logical::AND; return T_AND; }
"|"                 { yylval.logical = falk::op::Logical::OR; return T_OR; }
"!"                 { yylval.logical = falk::op::Logical::NOT; return T_NOT; }

"("                 { return T_OPAR; }
")"                 { return T_CPAR; }
"["                 { return T_OINDEX; }
"]"                 { return T_CINDEX; }
":"					{ return T_OBLOCK; }
"."					{ return T_CBLOCK; }
"="                 { return T_ASSIGN; }
","                 { return T_COMMA; }
{end_of_command}	{ return T_EOC; }

//[^\n]*\n					;
/\*([^\*]|\*[^/])*\*/		;

{nonacceptable}     { lexical_error("unknown symbol %s\n", strdup(yytext)); }

%%

template<typename... Args>
void lexical_error(Args... args) {
    std::fprintf(stderr, "[Line %d] lexical error: ", yylineno);
    std::fprintf(stderr, args...);
}

void yyerror(const char *s, ...){
    va_list ap;
    va_start(ap, s);
    std::fprintf(stderr, "[Line %d] ", yylineno);
    std::vfprintf(stderr, s, ap);
    std::cout << std::endl;
}
