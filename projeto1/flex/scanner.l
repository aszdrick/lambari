%{
#include <string>
#include <iostream>
#include "utils.hpp"
#include "parser.h" /* Generated by Bison */

extern int yylineno;
template<typename... Args>
void lexical_error(Args... args);
void yyerror(const char* s, ...);
%}

%option noyywrap nodefault yylineno

int_type int
float_type float
bool_type bool 

int_literal [0-9]+
float_literal [0-9]*\.[0-9]+|[0-9]+\.?[0-9]*
bool_literal true|false

var [a-zA-Z][a-zA-Z0-9_]*

if_literal if
then_literal then
else_literal else

for_literal for
return_keyword ret
function_keyword fun

nonacceptable [^-\+\*\\(\)/=,\n0-9A-Za-z_ \t]+
%%

[ \t]               ; //ignores spaces

{int_type}          { yylval.type = Type::INT; return T_TYPE; }
{float_type}        { yylval.type = Type::FLOAT; return T_TYPE; }
{bool_type}         { yylval.type = Type::BOOL; return T_TYPE; }

"["{int_type}"]"    { yylval.type = Type::INT; return T_CAST; }
"["{float_type}"]"  { yylval.type = Type::FLOAT; return T_CAST; }
"["{bool_type}"]"   { yylval.type = Type::BOOL; return T_CAST; }

{int_literal}       { yylval.value = {strdup(yytext), Type::INT}; return T_NUMBER; }
{float_literal}     { yylval.value = {strdup(yytext), Type::FLOAT}; return T_NUMBER; }
{bool_literal}      { yylval.value = {strdup(yytext), Type::BOOL}; return T_BOOL; }

{if_literal}        { return T_IF; }
{then_literal}      { return T_THEN; }
{else_literal}	 	{ return T_ELSE; }

{for_literal}       { return T_FOR; }
{return_keyword}    { return T_RET; }
{function_keyword}  { return T_FUN; }

{var}               { yylval.var = strdup(yytext); return T_VAR; }

"+"                 { yylval.operation = Operator::PLUS; return T_PLUS; }
"-"                 { yylval.operation = Operator::MINUS; return T_MINUS; }
"*"                 { yylval.operation = Operator::TIMES; return T_TIMES; }
"/"                 { yylval.operation = Operator::DIVIDE; return T_DIVIDE; }
"=="                { yylval.operation = Operator::EQUAL; return T_COMPARISON; }
"!="                { yylval.operation = Operator::NOT_EQUAL; return T_COMPARISON; }
">"                 { yylval.operation = Operator::GREATER_THAN; return T_COMPARISON; }
"<"                 { yylval.operation = Operator::LESS_THAN; return T_COMPARISON; }
">="                { yylval.operation = Operator::GREATER_EQUAL_THAN; return T_COMPARISON; }
"<="                { yylval.operation = Operator::LESS_EQUAL_THAN; return T_COMPARISON; }
"&"                 { yylval.operation = Operator::AND; return T_AND; }
"|"                 { yylval.operation = Operator::OR; return T_OR; }
"!"                 { yylval.operation = Operator::NOT; return T_NOT; }

"("                 { return T_OPAR; }
")"                 { return T_CPAR; }
"{"					{ return T_OBLOCK; }
"}"					{ return T_CBLOCK; }
"="                 { return T_ASSIGN; }
","                 { return T_COMMA;  }
\n                  { return T_NL; }
{nonacceptable}     { lexical_error("unknown symbol %s\n", strdup(yytext)); }

%%

template<typename... Args>
void lexical_error(Args... args) {
    std::fprintf(stderr, "[Line %d] lexical error: ", yylineno);
    std::fprintf(stderr, args...);
}

void yyerror(const char *s, ...){
    va_list ap;
    va_start(ap, s);
    std::fprintf(stderr, "[Line %d] ", yylineno);
    std::vfprintf(stderr, s, ap);
    std::cout << std::endl;
}
