%{
#include <string>
#include <iostream>
#include "parser.h" /* Generated by Bison */

extern int yylineno;
template<typename... Args>
void lexical_error(Args... args);
void yyerror(const char* s, ...);
%}

%option noyywrap nodefault yylineno

type int
num -?([0-9]+)
var ([a-zA-Z][a-zA-Z0-9_]*)
nonacceptable [^-\+\*\\(\)/=,\n0-9A-Za-z_ \t]+


%%

[ \t]               ; //ignores spaces
{type}				{ yylval.type = Type::INT; return T_TYPE; }
{var}               { yylval.var = strdup(yytext); return T_VAR; }
{num} 				{ yylval.value = std::atof(strdup(yytext)); return T_NUMBER; }
"+"                 { return T_PLUS; }
"-"					{ return T_MINUS; }
"*"                 { return T_TIMES; }
"/"					{ return T_DIVIDE; }
"("					{ return T_OPAR; }
")"					{ return T_CPAR; }
"="                 { return T_ASSIGN; }
","					{ return T_COMMA;  }
\n                  { return T_NL; }
{nonacceptable}	    { lexical_error("unknown symbol %s\n", strdup(yytext)); }

%%

template<typename... Args>
void lexical_error(Args... args) {
    std::fprintf(stderr, "[Line %d] lexical error: ", yylineno);
	std::fprintf(stderr, args...);
}

void yyerror(const char *s, ...){
    va_list ap;
    va_start(ap, s);
    std::fprintf(stderr, "[Line %d] ", yylineno);
    std::vfprintf(stderr, s, ap);
    std::cout << std::endl;
}
